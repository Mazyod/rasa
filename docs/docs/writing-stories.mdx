---
id: writing-stories
sidebar_label: Writing Stories
title: Writing Stories
---
import useBaseUrl from '@docusaurus/useBaseUrl';

Rasa Open Source uses machine learning for dialogue management to figure out what your
assistant should do next. The machine learning model is trained on example conversations
using [stories](./stories.mdx), a representation of a conversation where user inputs
are expressed as intents and bot responses are expressed as [actions](./actions.mdx).

## Designing Stories

When designing stories, there are two groups of conversational interactions that need
to be accounted for: happy and unhappy paths. Happy paths describe when the user is
following the conversation flow as you'd expect and always providing the necessary
information when prompted. As you might expect, users will often deviate from happy
paths with questions, chit chat, or other asks, making it important for your bot to
gracefully handle these unhappy paths.

Often, developers will try to account for every possible diverging path when designing
unhappy paths. In a happy path with N number of possible branching points, this would
require on the order of 2^N stories! Instead, we recommend taking a
[conversation-driven development](./conversation-driven-development.mdx) approach when designing
unhappy paths.

Conversation-Driven Development promotes sharing your bot as early as possible with test users and
collecting real conversation data that tells you exactly how users diverge from the
happy paths. From this data, you can create stories to accomplish what the user is
requesting and start to think about ways to guide them back into a happy path.



## When to use Stories vs. Rules
[Rules](./rules.mdx) are a type of training data used by the dialogue manager for
handling parts of conversations that should always follow the same path.

Example use cases for rules include:

* FAQ-style questions where there is a fixed response to a given question
(e.g. "What are the hours of operation?")

* Collecting user information via [Forms](./forms.mdx), such as asking for a mailing address

* [Fallback actions](./fallback-handoff.mdx) for handling messages with low confidence scores

Because rules do not generalize to unseen conversations, they should be reserved for
forms and single turn conversation parts while stories are used for training on
complete conversations.

An example of a rule where the bot returns a fixed response "utter_greet" to a user
message with intent "greet" would be:

```yaml-rasa
rules:
- rule: Greeting Rule
  steps:
  - intent: greet
  - action: utter_greet
```

For multiple-turn interactions, a story should be defined, for example:

```yaml-rasa
 - story: Greeting and ask user how they're doing
   steps:
   - intent: greet
   - action: utter_greet
   - action: utter_ask_how_doing
   - intent: doing_great
   - action: utter_happy
```




## Managing the Conversation Flow

Here are some tips for managing the conversation flow in your stories:

### When to use Featurized Slots

Slots are your botâ€™s memory and can be used to influence how the dialogue engine makes
predictions. These slots must be included in your story files when they are set by a
[custom action](./actions.mdx). Most slot types are passed into the dialogue engine as
featurized representations that only take into account whether or not the slot is set.
If the value of the slot itself is important, consider using a categorical or bool
slot type.

For example, a boolean slot set by a custom action can be used to affect the dialogue
flow based on its value using the following stories:

```yaml-rasa
- story: Welcome message, premium user
  steps:
   - intent: greet
   - action: action_check_profile
   - slot_was_set:
     - premium_account: True
   - action: utter_welcome_premium

- story: Welcome message, basic user
  steps:
   - intent: greet
   - action: action_check_profile
   - slot_was_set:
     - premium_account: False
   - action: utter_welcome_basic
   - action: utter_ask_upgrade
```

In cases where you don't want a slot to affect the conversation flow, an unfeaturized
slot should be used. Note that, unlike featurized slots, unfeaturized slots should not
be included in your story files.


### Where to Implement Branching Logic

When writing stories, it's important to find the right balance between using slots and
using custom action code to decide the next action your bot should take. In cases where
a slot value is used only to determine the bot's response, consider embedding the
decision logic inside a custom action as opposed to using a featurized slot in your
stories. This can help reduce overall complexity and make your stories easier to manage.

For example these stories:

```yaml-rasa
- story: It's raining now
  steps:
  - intent: check_for_rain
  - action: action_check_for_rain
  - slot_was_set:
    - raining: True
  - action: utter_is_raining
  - action: utter_bring_umbrella

- story: It isn't raining now
  steps:
  - intent: check_for_rain
  - action: action_check_for_rain
  - slot_was_set:
    - raining: False
  - action: utter_not_raining
  - action: utter_no_umbrella_needed
```

can be converted into a single story:

```yaml-rasa
- story: check for rain
  steps:
  - intent: check_for_rain
  - action: action_check_for_rain
```

with the custom action code:

```python
def run(self, dispatcher, tracker, domain):
	is_raining = check_rain()
	if is_raining:
		dispatcher.utter_message(template="utter_is_raining")
		dispatcher.utter_message(template="utter_bring_umbrella")
	else:
		dispatcher.utter_message(template="utter_not_raining")
		dispatcher.utter_message(template="utter_no_umbrella_needed")
	return []
```


### Using OR statements and Checkpoints

[OR statements](./stories.mdx#or-statements) and [checkpoints](./stories.mdx#checkpoints)
can be useful for reducing the number of stories you have to write, however, they should
be used with caution. Overusing OR statements will slow down training,
and creating too many checkpoints can make your stories hard to understand.

#### OR statements

In stories where different intents should be handled by your bot in the same way,
OR statements can be used as an alternative to creating a new story.

For example these two stories:

```yaml-rasa
- story: tell a joke, user thinks it's funny
  steps:
  - intent: tell_a_joke
  - action: utter_joke
  - action: utter_was_that_funny
  - intent: affirm
  - action: utter_happy

- story: tell a joke, user laughs
  steps:
  - intent: tell_a_joke
  - action: utter_joke
  - action: utter_was_that_funny
  - intent: laugh
  - action: utter_happy
```

can be merged into a single story with an OR statement:

```yaml-rasa
- story: tell a joke, user thinks it's funny
  steps:
  - intent: tell_a_joke
  - action: utter_joke
  - action: utter_was_that_funny
  - intent: affirm OR laugh
  - action: utter_happy
```

At training time, this story gets converted into the two original stories and provides
a more compact representation. If you notice that you are using OR statements frequently
in your stories, consider restructuring your intents to reduce their granularity and
more broadly capture user messages.

#### Checkpoints

Checkpoints are useful for modularizing your stories into separate blocks that are
repeated often. For example, if you want your bot to ask for user feedback at the end of
each conversation flow, you can use a checkpoint to avoid having to include the feedback
interaction at the end of each story:

```yaml-rasa
- story: beginning of conversation
  steps:
  - intent: greet
  - action: utter_greet
  - intent: goodbye
  - action: utter_goodbye
  - action: utter_ask_feedback
  - checkpoint: ask_feedback

- story: user provides feedback
  steps:
  - checkpoint: ask_feedback
  - intent: inform
  - action: utter_thank_you
  - action: utter_anything_else

- story: user doesn't have feedback
  steps:
  - checkpoint: ask_feedback
  - intent: deny
  - action: utter_no_problem
  - action: utter_anything_else
```

### Creating Logical Breaks in Stories

When designing conversation flows, it can be tempting to create long story
examples that capture a complete conversational interaction from start to finish.
In many cases, this will increase the number of training stories required
to account for branching paths. Instead, consider separating your
longer stories into smaller conversational blocks that handle sub-tasks.

A happy path story for handling a lost credit card might look like:

```yaml-rasa
- story: Customer loses a credit card, reviews transactions, and gets a new card
  steps:
  - intent: card_lost
  - action: utter_card_locked
  - action: spending_history_form
  - active_loop: spending_history_form
  - active_loop: null
  - slot_was_set:
  	- reviewed_transactions: ["starbucks"]
  - action: utter_ask_fraudulent_transactions
  - intent: inform
  - action: action_update_transactions
  - slot_was_set:
  	- reviewed_transactions: ["target", "starbucks"]
  - intent: affirm
  - action: utter_confirm_transaction_dispute
  - action: utter_replace_card
  - action: mailing_address_form
  - active_loop: mailing_address
  - active_loop: null
  - action: utter_sent_replacement
  - action: utter_anything_else
  - intent: affirm
  - action: utter_help
```

Handling a lost credit card involves a series of sub-tasks, namely
checking spending history for fraudulent transactions, confirming a mailing
address for a replacement card, and then following up with the user
with any additional requests. In this conversation arc, there are
several places where the bot prompts for user input, creating
branching paths that need to be accounted for.

For example, when prompted with "utter_ask_fraudulent_transactions",
the user might respond with a "deny" intent if none are applicable.
The user might also choose to respond with a "deny" intent when asked
if there's anything else the bot can help them with.

We can separate out this long story into several smaller stories as:

```yaml-rasa
- story: Customer loses a credit card
  steps:
  - intent: card_lost
  - action: utter_card_locked
  - action: spending_history_form
  - active_loop: spending_history_form
  - active_loop: null
  - slot_was_set:
  	- reviewed_transactions: ["starbucks"]
  - action: utter_ask_fraudulent_transactions

- story: Customer reviews transactions and gets a new card
  steps:
  - action: utter_ask_fraudulent_transactions
  - intent: inform
  - action: action_update_transactions
  - slot_was_set:
  	- reviewed_transactions: ["target", "starbucks"]
  - intent: affirm
  - action: utter_confirm_transaction_dispute
  - action: utter_replace_card
  - action: mailing_address_form
  - active_loop: mailing_address
  - active_loop: null
  - action: utter_sent_replacement
  - action: utter_anything_else

- story: Customer has something else they need help with
  steps:
  - action: utter_anything_else
  - intent: affirm
  - action: utter_help
```

## Handling Context Switching

Often, users will not respond with the information you ask of them and instead deviate
from the happy path with unrelated questions. Using
[CDD](./conversation-driven-development.mdx) to understand
what unhappy paths your users are taking, you can create stories for handling context
switching.


### Using Rules for Context Switching

In some cases, such as handling single-turn interjections, context-switching can be
handled using [rules](./rules.mdx) instead of through [stories](./stories.mdx).

Consider this conversation scenario:

```
User: "Hi, I want to pay my credit card bill"
Bot: "Can do! Which of these credit accounts do you want to make a payment towards?
      - Credit Account A
      - Credit Account B"
User: "Credit account B"
Bot: "How much do you want to pay?"
User: "What's my account balance?"
Bot: "Your current account balance is $1532.00"
Bot: "How much do you want to pay?"
User: "I want to pay the minimum balance"
```

In this example, the user is in the middle of paying their credit card bill, asks for
their account balance, and is then guided back into the credit card payment form.
Because asking for the account balance triggers the same action regardless of context,
you can create a rule that will automatically be triggered inside of an existing flow:

```yaml-rasa
- rule: Check my account balance
  steps:
  - intent: check_account_balance
  - action: action_get_account_balance
```


By default, the form will continue to stay active and re-prompt for the necessary
information, without having to create an additional training story.

### Using Stories for Context Switching

You'll need to write additional stories for handling context switching when the
user's interjection requires multiple conversation turns. If you have two distinct
conversational flows and want the user to be able to switch between the flows, you will
need to create stories that specify how the switching will occur and how the context
is maintained.

For example, if you want to switch context upon a user ask and then return to the
original flow after that ask is complete:

```
User: "Hi, I want to pay my credit card bill"
Bot: "Can do! Which of these credit accounts do you want to make a payment towards?
      - Credit Account A
      - Credit Account B"
User: "Credit account B"
Bot: "How much do you want to pay?"
User: "Actually, I want to make a transfer"
Bot: "No problem!"
Bot: "Who would you like to transfer money to?"
User: "I want to send $500 to Katy Parrow"
Bot: "Can you confirm that you would like to send $500 to Katy Parrow?"
User: "Yes"
Bot: "Successfully transferred $500 to Katy Parrow."
Bot: "Would you like to pay your credit card bill now?"
```

You will need to create a story that describes this context-switching interaction:

```yaml-rasa
- story: Context switch from credit card payment to money transfer
  steps:
  - intent: pay_credit_card
  - action: credit_card_payment_form
  - active_loop{"name": "credit_card_payment_form"}
  - intent: transfer_money                         # user requests a money transfer
  - active_loop{"name": null}                      # deactivate the credit card form
  - action: transfer_money_form                    # switch to the money transfer form
  - active_loop{"name": "transfer_money_form"}
  - active_loop{"name": null}
  - action: utter_continue_credit_card_payment     # once the money transfer is completed,
                                                   # ask the user to return to the
                                                   # credit card payment form
```

## Managing Story Files

You can provide training data to Rasa Open Source in Markdown format as
a single file or as a directory containing multiple files.
When writing stories, it's usually a good idea to create separate
story files based on the types of conversations being represented.

For example, you might create a file `chitchat.md` for handling chitchat
stories and an `faqs.md` file for FAQ's.
Refer to our [rasa-demo bot](https://github.com/RasaHQ/rasa-demo)
for examples of story file management in complex assistants.


## Using Interactive Learning

Interactive learning makes it easy to write stories by talking to your bot and providing feedback.
This is a powerful way to explore what your bot can do, and the easiest way to fix any mistakes
it makes. One advantage of machine learning-based dialogue is that when
your bot doesn't know how to do something yet, you can just teach it!

In Rasa Open Source, you can run interactive learning in the command line with
[`rasa interactive`](./command-line-interface.mdx#interactive-learning).
[Rasa X](http://rasa.com/docs/rasa-x) provides a UI for interactive learning,
and you can use any user conversation as a starting point.
See [Talk to Your Bot](https://rasa.com/docs/rasa-x/user-guide/share-assistant/#talk-to-your-bot)
in the Rasa X docs.

<!-- TODO info about using interactive learning locally, can come from old docs -->

---
id: responses
sidebar_label: Responses
title: Responses
abstract: Responses are messages that your assistant sends to the user. A response
 is typically a text, but it can include other content like images and buttons.
---
## Defining Responses

Responses go under the `responses` key in your [domain](./domain.mdx) file. Start each
response name with `utter_`.

Here is an example of a domain file with two responses called `utter_greet` and `utter_bye`:

```yaml-rasa {4-8} title="domain.yml"
intents:
  - greet

responses:
  utter_greet:
  - text: "Hi there!"
  utter_bye:
  - text: "See you!"
```

If you use [retrieval actions](./retrieval-actions.mdx), make sure to define the responses 
for each retrieval action in your domain file, like in the following example:
```yaml-rasa
responses:
  utter_chitchat/ask_name:
  - text: Oh yeah, I am called the retrieval bot.

  utter_chitchat/ask_weather:
  - text: Oh, it does look sunny right now in Berlin.
```
:::note
Notice the special format of each retrieval action's name. The name starts with `utter_`, 
followed by the retrieval intent's name (here `chitchat`) and finally a suffix specifying 
the different response keys (here `ask_name` and `ask_weather`). See 
[Retrieval Actions](./retrieval-actions.mdx) and examples of [retrieval intents](./training-data-format.mdx#training-examples) to learn more.
:::

### Using Variables in Responses

You can use variables to insert information into responses.
Within a response, a variable is represented by using curly braces, see the variable `name` below:
```yaml-rasa {3} title="domain.yml"
responses:
  utter_greet:
  - text: "Hey, {name}. How are you?"
```

Now, when the `utter_greet` response is used, Rasa automatically fills in the variable with the value
found in the slot called `name`. If such a slot doesn't exist or is empty, the variable gets
filled with `None`.

Another way to fill in a variable is within a [custom action](./custom-actions.mdx).
In an action's code, you can supply values to a response to fill in specific variables. 
If you're using Rasa SDK for your action server, you can specify values when using `dispatcher.utter_message`:
```python {3}
dispatcher.utter_message(
    template="utter_greet",
    name="Sara"
)
```

If using a different custom action server, you can add extra parameters to the responses you return
to achieve the same result:

```json {8}
{
  "events":[
    ...
  ],
  "responses":[
    {
      "template":"utter_greet",
      "name":"Sara"
    }
  ]
}
```


### Response Variations

If you want to randomly vary the response sent to the user, you can list
multiple response variations by adding another response to the list of
responses under your response name.

The following example has 2 different choices for `utter_greet`:

```yaml-rasa title="domain.yml"
responses:
  utter_greet:
  - text: "Hey, {name}. How are you?"
  - text: "Hey, {name}. How is your day going?"
```

When the model predicts `utter_greet`, Rasa will randomly pick one of them.


### Channel-Specific Response Variations

If you want to specify different response variations that depend on which channel
the user is connected to, you can do this with channel-specific response variations.

Each time your bot looks for a response variation under a given response name, it will first check
to see if there are any channel-specific response variations for the connected channel.
If there are, it will choose a response from **only** these response variations.

If no channel-specific response variations are
found, the bot will choose from any response variations that do not have a defined `channel`.

:::caution
It is good practice to always have at least one response variation for each
response that has no `channel` specified. This allows your bot to respond in all
environments, including in new environments, in the shell, and in interactive learning.
:::

#### Defining Channel-Specific Response Variations

Channel-specific responses are defined in a response with the `channel` key.

The following example shows how you might use channel-specific responses to send a
specific `utter_ask_game` response to the `slack` channel:

```yaml-rasa title="domain.yml"
responses:
  utter_ask_game:
  - text: "Which game would you like to play?"
    channel: "slack"
    custom:
        blocks:
        - type: actions
          elements:
          - type: button
            text:
              type: plain_text
              emoji: true
              text: "Chess :crown:"
            value: '/inform{"game": "chess"}'
          - type: button
            text:
              type: plain_text
              emoji: true
              text: "Checkers :checkered_flag:"
            value: '/inform{"game": "checkers"}'
  - text: "Which game would you like to play?"
    buttons:
    - title: "Chess"
      payload: '/inform{"game": "chess"}'
    - title: "Checkers"
      payload: '/inform{"game": "checkers"}'
```

When using channel-specific responses, the value of the `channel` key should match
the name used to provide the credentials for that channel
in the `credentials.yml` file.

The second response variation, in this case, does not have a defined `channel`, which means it
will be the response used on all channels other than `slack`.


## Rich Responses

Rich responses allow you to add visual and interactive elements to your responses.
There are a few types of rich responses that are supported across multiple channels. These
can be added to the `text` of your response.

You can also use `custom` content to send a rich response of any type to the output channel.
Custom responses do not require any `text`, but may if your channel supports it.

### Buttons

Here is an example of a response that uses buttons:

```yaml-rasa title="domain.yml"
responses:
  utter_greet:
  - text: "Hey! How are you?"
    buttons:
    - title: "great"
      payload: "/mood_great"
    - title: "super sad"
      payload: "/mood_sad"
```
Each button in the list of `buttons` should have two keys:
* `title`: The text displayed on the buttons that the user sees.
* `payload`: The message sent from the user to the bot when a user clicks a given button.

:::note bypass nlu with buttons
It's common to use buttons as a shortcut to bypass NLU.
Rasa Open Source will send messages starting with a `/` to the
`RegexInterpreter`, which expects NLU input in a shortened `/intent{entities}` format.
In the above example, if a user clicks either button to respond with their mood, the user input
will be directly classified as either the `/mood_great` or `/mood_sad` intent.
:::

:::caution Check your channel
Keep in mind that it is up to the implementation of the output
channel on how to display the defined buttons. For example, some channels define a limit for the number of
buttons you can provide. Check your channel's documentation under
**Concepts > Channel Connectors** for any channel-specific restrictions.

:::

### Images

You can add images to a response by providing a URL to the image under the `image` key:

```yaml-rasa title="domain.yml"
  utter_cheer_up:
  - text: "Here is something to cheer you up:"
    image: "https://i.imgur.com/nGF1K8f.jpg"
```

### Custom Output Payloads

You can send any arbitrary output to the output channel using the
`custom:` key.

Note that since the domain is in yaml format, a json payload
payload should first be converted to yaml format.

For example, although date pickers are not a defined parameter in responses
because they are not supported by most channels, a Slack date picker
can be sent like so:

```yaml-rasa title="domain.yml"
responses:
  utter_take_bet:
  - custom:
      blocks:
      - type: section
        text:
          text: "Make a bet on when the world will end:"
          type: mrkdwn
        accessory:
          type: datepicker
          initial_date: '2019-05-21'
          placeholder:
            type: plain_text
            text: Select a date
```


## Using Responses in Conversations

### Calling Responses as Actions

1. So long as the name of the response starts with `utter_`, the response can
   directly be used as an action. You would add the response
   to the domain:

```yaml-rasa title="domain.yml"
   responses:
     utter_greet:
     - text: "Hey! How are you?"
   ```

   Afterwards, you can use the response as an action in the
   stories:

```yaml-rasa title="domain.yml"
   stories:
   - story: greet user
     steps:
     - intent: greet
     - action: utter_greet
```

When `utter_greet` is run as an action, it will send the message from
the response back to the user.

:::note
If you want to change the text, or any other part of the bots response,
you need to retrain the assistant before these changes will be picked up.

:::

### Calling Responses from Custom Actions

2. You can use the responses to generate response messages from your
   custom actions using the dispatcher:
   `dispatcher.utter_message(template="utter_greet")`.
   This allows you to separate the logic of generating
   the messages from the actual copy. In your custom action code, you can
   send a message based on the response like this:

   ```python
   from rasa_sdk.actions import Action

   class ActionGreet(Action):
     def name(self):
         return 'action_greet'

     def run(self, dispatcher, tracker, domain):
         dispatcher.utter_message(template="utter_greet")
         return []
   ```

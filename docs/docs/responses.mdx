---
id: responses
sidebar_label: Responses
title: Responses
abstract: Responses are messages that your assistant sends to the user. A response
 is typically a text, but it can include other content like images and buttons.
---
## Defining Responses

Responses go under the `responses` key in your [domain](./domain.mdx) file. Start each
response name with `utter_`.

Here is an example of a domain file with two responses called `utter_greet` and `utter_bye`:

```yaml-rasa {4-8} title="domain.yml"
intents:
  - greet

responses:
  utter_greet:
  - text: "Hi there!"
  utter_bye:
  - text: "See you!"
```

If you use [retrieval actions](./retrieval-actions.mdx), make sure to define the responses 
for each retrieval action in your domain file, like in the following example:
```yaml-rasa
responses:
  utter_chitchat/ask_name:
  - text: Oh yeah, I am called the retrieval bot.

  utter_chitchat/ask_weather:
  - text: Oh, it does look sunny right now in Berlin.
```
:::note
Notice the special format of each retrieval action's name. The name starts with `utter_`, 
followed by the retrieval intent's name (here `chitchat`) and finally a suffix specifying 
the different response keys (here `ask_name` and `ask_weather`). See 
[Retrieval Actions](./retrieval-actions.mdx) and examples of [retrieval intents](./training-data-format.mdx#training-examples) to learn more.
:::

### Using Variables in Responses

You can use variables to insert information into responses.
Within a response, a variable is enclosed in curly brackets, see the variable `name` below:
```yaml-rasa {3} title="domain.yml"
responses:
  utter_greet:
  - text: "Hey, {name}. How are you?"
```

Now, when the `utter_greet` response is used, Rasa automatically fills in the variable with the value
found in the slot called `name`. If such a slot doesn't exist or is empty, the variable gets
filled with `None`.

Another way to fill in a variable is within a [custom action](./custom-actions.mdx).
In such an action's code, you can supply values to a response to fill in specific variables. 
If you use Rasa SDK for your action server, you can do this when using `dispatcher.utter_message`:
```python {3}
dispatcher.utter_message(
    template="utter_greet",
    name="Sara"
)
```

If you use a [different custom action server](https://rasa.com/docs/action-server#other-action-servers), 
supply the values by adding extra parameters to the responses you return:
```json {8}
{
  "events":[
    ...
  ],
  "responses":[
    {
      "template":"utter_greet",
      "name":"Sara"
    }
  ]
}
```


### Response Variations

You can make your assistant's replies more interesting by giving it multiple response variations to choose 
from for a given response name:
```yaml-rasa {3-4} title="domain.yml"
responses:
  utter_greet:
  - text: "Hey, {name}. How are you?"
  - text: "Hey, {name}. How is your day going?"
```
In this example, when `utter_greet` gets predicted as the next action, Rasa will randomly pick one of the 
two response variations and use it.


### Channel-Specific Response Variations

If you want to specify different response variations that depend on which channel
the user is connected to, you can do this with channel-specific response variations.

Each time your bot looks for a response variation under a given response name, it will first check
to see if there are any channel-specific response variations for the connected channel.
If there are, it will choose a response from **only** these response variations.

If no channel-specific response variations are
found, the bot will choose from any response variations that do not have a defined `channel`.

:::caution
It is good practice to always have at least one response variation for each
response that has no `channel` specified. This allows your bot to respond in all
environments, including in new environments, in the shell, and in interactive learning.
:::

#### Defining Channel-Specific Response Variations

Channel-specific responses are defined in a response with the `channel` key.

The following example shows how you might use channel-specific responses to send a
specific `utter_ask_game` response to the `slack` channel:

```yaml-rasa title="domain.yml"
responses:
  utter_ask_game:
  - text: "Which game would you like to play?"
    channel: "slack"
    custom:
        blocks:
        - type: actions
          elements:
          - type: button
            text:
              type: plain_text
              emoji: true
              text: "Chess :crown:"
            value: '/inform{"game": "chess"}'
          - type: button
            text:
              type: plain_text
              emoji: true
              text: "Checkers :checkered_flag:"
            value: '/inform{"game": "checkers"}'
  - text: "Which game would you like to play?"
    buttons:
    - title: "Chess"
      payload: '/inform{"game": "chess"}'
    - title: "Checkers"
      payload: '/inform{"game": "checkers"}'
```

When using channel-specific responses, the value of the `channel` key should match
the name used to provide the credentials for that channel
in the `credentials.yml` file.

The second response variation, in this case, does not have a defined `channel`, which means it
will be the response used on all channels other than `slack`.


## Rich Responses

Rich responses allow you to add visual and interactive elements to your responses.
There are a few types of rich responses that are supported across multiple channels. These
can be added to the `text` of your response.

You can also use custom content to send a rich response of any type to the output channel.

### Buttons

Here is an example of a response that uses buttons:

```yaml-rasa {4-8} title="domain.yml"
responses:
  utter_greet:
  - text: "Hey! How are you?"
    buttons:
    - title: "great"
      payload: "/mood_great"
    - title: "super sad"
      payload: "/mood_sad"
```

Each button in the list of `buttons` should have two keys:
* `title`: The text displayed on the buttons that the user sees.
* `payload`: The message sent from the user to the bot when the button is clicked.

:::note bypass nlu with buttons
It's common to use buttons as a shortcut to bypass the ML-based NLU interpreter.
Messages starting with `/` are sent straight to the
`RegexInterpreter`, which expects NLU input in a shortened `/intent{entities}` format.
In the example above, if the user clicks a button, the user input
will be directly classified as either the `/mood_great` or `/mood_sad` intent.
:::

:::caution Check your channel
Keep in mind that it is up to the implementation of the output
channel how to display the defined buttons. For example, some
channels have a limit on the number of
buttons you can provide. Check your channel's documentation under
**Concepts > Channel Connectors** for any channel-specific restrictions.
:::

### Images

You can add images to a response by providing a URL to the image under the `image` key:

```yaml-rasa {3} title="domain.yml"
  utter_cheer_up:
  - text: "Here is something to cheer you up:"
    image: "https://i.imgur.com/nGF1K8f.jpg"
```

### Custom Output Payloads

You can send any arbitrary output to the output channel using the
`custom` key.

Here's an example of how to send a
[date picker](https://api.slack.com/reference/block-kit/block-elements#datepicker) to the
[Slack Output Channel](connectors/slack.mdx):

```yaml-rasa title="domain.yml"
responses:
  utter_take_bet:
  - custom:
      blocks:
      - type: section
        text:
          text: "Make a bet on when the world will end:"
          type: mrkdwn
        accessory:
          type: datepicker
          initial_date: '2019-05-21'
          placeholder:
            type: plain_text
            text: Select a date
```

## Using Responses in Conversations

### Calling Responses as Actions

So long as the name of the response starts with `utter_`, the response can
directly be used as an action. Say you have the following response in your domain:

```yaml-rasa title="domain.yml"
   responses:
     utter_greet:
     - text: "Hey! How are you?"
   ```

You can use that same response as an action in your stories:

```yaml-rasa title="stories.yml"
   stories:
   - story: greet user
     steps:
     - intent: greet
     - action: utter_greet
```

When `utter_greet` action runs, it will send the message from
the response back to the user.

:::note
If you want to change the text, or any other part of the response,
you need to retrain the assistant before these changes will be picked up.
:::

### Calling Responses from Custom Actions

You can call responses from your
[Custom Actions](custom-actions.mdx) by using the `dispatcher`
variable. In your custom action code, you can
send a message based on the responses defined under `utter_greet` like this:

```python
from rasa_sdk.interfaces import Action

class ActionGreet(Action):
 def name(self):
     return 'action_greet'

 def run(self, dispatcher, tracker, domain):
     dispatcher.utter_message(template="utter_greet")
     return []
```

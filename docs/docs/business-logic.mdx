---
id: business-logic
sidebar_label: Handling Business Logic
title: Handling Business Logic
abstract: Conversational assistants often need to ask users for information in order to help them. You can use 
---

Conversational assistants often support user goals that involve collecting required information
from the user before doing something for them. For example, a restaurant search bot would need to gather a few pieces of information
about the user's preferences to find them a suitable restaurant:

```yaml
User: Help me find a restaurant
    Bot: What cuisine?
User: I'm looking for Tuscan food
    Bot: How many people?
User: 5
    Bot: Do you want to sit outside?
User: Yes
    Bot: All done!
    Bot: I am going to run a restaurant search using the following parameters:
          - cuisine: Tuscan
          - num_people: 5
          - outdoor_seating: True
```

This type of behavior can and should be handled in a rule based way, as it
is clear how this information should be collected.
This page is a guide on handling business logic. 
In the example above, business logic includes needing to know the user's preferred cuisine, party size, and seating preference.
It uses abbreviated examples from the [formbot example bot](https://github.com/RasaHQ/rasa/tree/master/examples/formbot).
Adapt the example
described in this guide to build an assistant that can handle a conversation
like the one above, or apply the guidelines to your own use case.

## Using Forms to Handle Business Logic

[Forms](forms.mdx) work by prompting the user for information until it has gathered all required information.
The information is stored in [slots](domain.mdx#slots). Once all the required slots are filled,
the bot fulfills the user's original request.


### 1. Defining the form

#### Required Slots

For the restaurant search example, we want to collect the following information
from the user:

- cuisine
- number of people
- whether they want to sit outside or not


You define a form in the domain file (domain.yml) by specifying [slot mappings](forms.mdx#slot-mappings) for each
piece of required information:

```rasa-yaml
  - restaurant_form:
      cuisine:
        - type: from_entity
          entity: cuisine
      num_people:
        - type: from_entity
          entity: number
      outdoor_seating:
        - type: from_intent
          intent: affirm
          value: true
        - type: from_intent
          intent: deny
          value: false
```


See the following section for an explanation of what the slot mappings mean.

Since the form relies on certain slots being available,  you need to add these slots to the domain. Slots filled by
forms are usually `unfeaturized`, since their value doesn't change
the flow of the conversation.

```rasa-yaml
slots:
  cuisine:
    type: unfeaturized
    auto_fill: false
  num_people:
    type: unfeaturized
    auto_fill: false
  outdoor_seating:
    type: unfeaturized
    auto_fill: false
```

#### Filling Slots

[`Slot mappings`](forms.mdx#slot-mappings) define how a slot in a form can be filled.
By default, a slot will be filled by an entity with the same name.

The `cuisine` slot is filled from the entity of the same name.
The `num_people` slot is filled by the `number` entity. Entities like numbers
are best extracted using the [`DucklingEntityExtractor`](entity-extractors.mdx#ducklingentityextractor),
while `cuisine` is a custom entity that will need to be extracted by the `DIETClassifier`.
To extract these two entities, you need to add `DIETClassifier` and `DucklingEntityExtractor`
to your NLU pipeline in `config.yml`:

```rasa-yaml
language: en
pipeline:
# other components
- DIETClassifier
  epochs: 100
- DucklingEntityExtractor:
  dimensions: ["number"]
```


The `outdoor_seating` slot is
filled based on the user's intent: If it is `affirm`, it'll be `true`, if it is
`deny`, it'll be `false`.


#### Validating Slots

Often, you'll want to validate the user's input before accepting it,
for example by checking if the given cuisine is in your assistant's database
of available cuisines.
See the docs on [validating form input](forms.mdx#validating-form-input) for more information
about validation actions.

#### Requesting Slots

To specify how the bot should ask for the required information,
you define [`responses`](domain.mdx#responses) called `utter_ask_{slotname}` in your domain.
For the restaurant search example, the responses look like this:

```rasa-yaml
responses:
  utter_ask_cuisine:
    - text: "What cuisine?"
  utter_ask_num_people:
    - text: "How many people?"
  utter_ask_outdoor_seating:
    - text: "Do you want to sit outside?"
```

#### Completing the Form

Once all required slots have been filled, the bot can act on the
information it has collected. Depending on the use case, the assistant
might just respond with a message, or take a more complicated action behind
the scenes before responding to the user.

For the restaurant search example, in real life the assistant would look up
a restaurant based on the user's preferences.
In this case, the bot will just utter a response with the details
that would be used for a search.


### 2. Updating the configuration

A form's [happy path](glossary.mdx#happy-path) should be defined as a [rule](rules.mdx) which means you'll need to add the [`RulePolicy`](policies.mdx#rulepolicy)
to your policies in your configuration file:

```rasa-yaml
policies:
  - name: RulePolicy
```

### 3. Creating rules

You need two rules for a form's happy path:
One to activate it, and one to submit it.
All the slot collection happens inside the form, and
therefore doesn't need to be covered explicitly by a rule.


```rasa-yaml
  - rule: activate restaurant form
    steps:
      - intent: request_restaurant
      - action: restaurant_form
      - active_loop: restaurant_form

  - rule: submit form
    condition:
    - active_loop: restaurant_form
    steps:
      - action: restaurant_form
      - active_loop: null
      - action: utter_submit
      - action: utter_slots_values
```

By splitting up the activation and submission of the form,
the rules will still apply if the user provides
[unexpected input](unexpected-input.mdx) or interrupts
the form with [chitchat](chitchat-faqs.mdx).


### 4. Updating the NLU training data

You'll need to add examples for the intent that should activate the form, as well as
examples for how the user will provide the required information.

#### Form Activation Intent(s)

You need to provide training examples for the
intent(s) that should activate the form.
For the restaurant search use case, we want the intent `request_restaurant` to activate the form:

```rasa-yaml
nlu:
- intent: request_restaurant
  examples: |
    - im looking for a restaurant
    - can i get [swedish](cuisine) food in any area
    - a restaurant that serves [caribbean](cuisine) food
    - id like a restaurant
    - im looking for a restaurant that serves [mediterranean](cuisine) food
    - can i find a restaurant that serves [chinese](cuisine)
```

Slots filled `from_entity` can by default be filled by any user utterance, regardless of the intent, as
long as the correct entity is extracted. That means that if the user provides the `cuisine` entity as part of
their first message, the slot will be filled at the beginning of the form and the bot will not
ask them for the cuisine again.

#### Form Filling Intent(s)

While the form is filling slots, it will not pay attention to which intent was predicted
unless a slot mapping explicitly requires or excludes an intent.

For the restaurant search example, the `outdoor_seating` slot is mapped to two intents,
so you need to add training data for these intents.

For the `cuisine` and `number` slots, no intent is specified, so you can add examples to a generic `inform` intent. You need
to annotate the `cuisine` entity so that `DIETClassifier` can
learn to extract it. You don't need to annotate the `number` entity since `DucklingEntityExtractor` is a rule-based extractors
that isn't trained on your training data. Only a few examples are shown for each intent;
for your bot to work well, you should add more training data than is shown here:


```rasa-yaml
nlu:
- intent: affirm
  examples: |
    - Yes
    - yes, please
    - yup
- intent: deny
  examples: |
    - no don't
    - no
    - no I don't want that

- intent: inform
  examples: |
    - [afghan](cuisine) food
    - how bout [asian oriental](cuisine)
    - what about [indian](cuisine) food
    - uh how about [turkish](cuisine) type of food
    - um [english](cuisine)
    - im looking for [tuscan](cuisine) food
    - id like [moroccan](cuisine) food
    - for ten people
    - 2 people
    - for three people
    - just one person
    - book for seven people
    - 2 please
    - nine people
```

Be sure to update your domain file to include these added intents.

### 5. Defining the responses

You should include a response for asking for each required slot and
for responding after the form has been submitted:

```rasa-yaml
responses:
  utter_ask_cuisine:
    - text: "What cuisine?"
  utter_ask_num_people:
    - text: "How many people?"
  utter_ask_outdoor_seating:
    - text: "Do you want to seat outside?"
  utter_submit:
    - text: "All done!"
  utter_slots_values:
    - text: "I am going to run a restaurant search using the following parameters:\n
             - cuisine: {cuisine}\n
             - num_people: {num_people}\n
             - outdoor_seating: {outdoor_seating}
```

## Summary

Forms can greatly simplify the logic of collecting user
information. To define a minimal form like the restaurant search
example above, this is a summary of what you'll need to do:

- [ ] Add `RulePolicy` to your policies in `config.yml`
- [ ] Define the form with slot mappings
- [ ] Add all required slots to the domain
- [ ] Add rules for activating and submitting the form
- [ ] Add examples for the intent to activate your form
- [ ] Add examples for the intent(s) to fill the required slots
- [ ] Define an action or response for the bot to take when the form is completed
- [ ] Update your domain with new intents and actions you've defined

To try out your newly defined form, retrain the bot and start `rasa shell`.
If your final action is a custom action, you'll need to start the action server
in a separate terminal when running `rasa shell`. If you're using `DucklingEntityExtractor` to extract
entities, you'll need to start Duckling in the background as well
(see the [instructions for running Duckling](entity-extractors.mdx#ducklingentityextractor)).

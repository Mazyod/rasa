import argparse
import os
import sys
from pathlib import Path
from subprocess import CalledProcessError, check_call, check_output
from typing import Text

import questionary
import semantic_version
from semantic_version import Version

VERSION_FILE_PATH = "rasa/version.py"

REPO_BASE_URL = "https://github.com/RasaHQ/rasa"


def create_argument_parser() -> argparse.ArgumentParser:
    """Parse all the command line arguments for the run script."""

    parser = argparse.ArgumentParser(description="prepare the next library release")
    parser.add_argument(
        "--next_version",
        type=str,
        help="Either next version number or 'major', 'minor', 'patch'",
    )

    return parser


def _project_root():
    return Path(os.path.dirname(__file__)) / ".."


def _version_file_path() -> Path:
    return _project_root() / VERSION_FILE_PATH


def write_version_file(version: Text) -> None:
    with _version_file_path().open("w") as f:
        f.write(
            f'__version__ = "{version}"  '
            f"# this is autogenerated DO NOT CHANGE THIS FILE!\n"
        )
    check_call(["git", "add", str(_version_file_path().absolute())])


def get_current_version():
    """Return the current library version"""

    if not _version_file_path().is_file():
        raise FileNotFoundError(
            f"Failed to find version file at {_version_file_path().absolute()}"
        )

    _globals = {"__version__": None}
    with _version_file_path().open() as f:
        exec(f.read(), _globals)
    return _globals.get("__version__")


def confirm_version(version):
    """Allow the user to confirm the version number."""

    if version in get_existing_tags():
        confirmed = questionary.confirm(
            f"Tag with version '{version}' already exists, overwrite?", default=False
        ).ask()
    else:
        confirmed = questionary.confirm(
            f"Is the next version '{version}' correct?", default=True
        ).ask()
    if confirmed:
        return True
    else:
        print("Aborting.")
        sys.exit(1)


def ask_version() -> Text:
    """Allow the user to confirm the version number."""

    def is_valid(v):
        try:
            return v in {"major", "minor", "patch"} or Version.coerce(v) is not None
        except:
            return False

    version = questionary.text(
        "What is the version number you want to release "
        "('major', 'minor', 'patch' or valid version number]?",
        validate=is_valid,
    ).ask()

    if version:
        return version
    else:
        print("Aborting.")
        sys.exit(1)


def get_existing_tags():
    stdout = check_output(["git", "tag"])
    return set(stdout.decode().split("\n"))


def git_current_branch():
    try:
        return check_output(["git", "symbolic-ref", "--short", "HEAD"]).decode().strip()
    except CalledProcessError:
        return "master"


def parse_next_version(version):
    if version == "major":
        return str(Version.coerce(get_current_version()).next_major())
    elif version == "minor":
        return str(Version.coerce(get_current_version()).next_minor())
    elif version == "patch":
        return str(Version.coerce(get_current_version()).next_patch())
    elif semantic_version.validate(version):
        return version
    else:
        raise Exception(f"Invalid version number '{cmdline_args.next_version}'.")


def next_version(args) -> Text:
    return parse_next_version(args.next_version or ask_version())


def generate_changelog(version):
    check_call(["towncrier", "--yes", "--version", version], cwd=str(_project_root()))


def create_release_branch(version):
    branch = f"prepare-release-{version}"
    check_call(["git", "checkout", "-b", branch])
    return branch


def create_commit(version):
    check_call(["git", "commit", "-m", f"prepared release of version {version}"])


def push_changes():
    check_call(["git", "push", "origin", "HEAD"])


def print_done_message(branch, base, version):
    url = f"{REPO_BASE_URL}/compare/{base}...{branch}?expand=1"
    print()
    print(f"\033[94m All done - changes for version {version} are ready! \033[0m")
    print()
    print(f"Please open a PR on GitHub: {url}")


def ensure_clean_git():
    try:
        check_call(["git", "diff-index", "--quiet", "HEAD", "--"])
    except CalledProcessError:
        print("Your git is not clean. Release script can only be run from a clean git.")
        sys.exit(1)


def main(args):
    ensure_clean_git()
    version = next_version(cmdline_args)
    confirm_version(version)

    write_version_file(version)

    generate_changelog(version)
    base = git_current_branch()
    branch = create_release_branch(version)
    create_commit(version)
    push_changes()
    print_done_message(branch, base, version)


if __name__ == "__main__":
    arg_parser = create_argument_parser()
    cmdline_args = arg_parser.parse_args()
    main(cmdline_args)
